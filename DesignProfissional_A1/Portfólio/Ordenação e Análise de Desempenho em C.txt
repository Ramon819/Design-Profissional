#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Estrutura para as métricas
typedef struct {
    long long steps_cmp, steps_swap;
} Metrics;

// Função para resetar métricas
void reset_metrics(Metrics *m) {
    m->steps_cmp = 0;
    m->steps_swap = 0;
}

// MERGE SORT 

void merge(int *v, int left, int mid, int right, Metrics *m) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    int *L = malloc(n1 * sizeof(int));
    int *R = malloc(n2 * sizeof(int));

    for (int i = 0; i < n1; i++) L[i] = v[left + i];
    for (int i = 0; i < n2; i++) R[i] = v[mid + 1 + i];

    int i = 0, j = 0, k = left;

    while (i < n1 && j < n2) {
        m->steps_cmp++;
        if (L[i] <= R[j]) {
            v[k++] = L[i++];
        } else {
            v[k++] = R[j++];
        }
        m->steps_swap++;
    }

    while (i < n1) {
        v[k++] = L[i++];
        m->steps_swap++;
    }
    while (j < n2) {
        v[k++] = R[j++];
        m->steps_swap++;
    }

    free(L);
    free(R);
}

void merge_sort(int *v, int left, int right, Metrics *m) {
    if (left < right) {
        int mid = (left + right) / 2;
        merge_sort(v, left, mid, m);
        merge_sort(v, mid + 1, right, m);
        merge(v, left, mid, right, m);
    }
}

// Função auxiliar para usar Merge Sort
void merge_sort_wrapper(int *v, size_t n, Metrics *m) {
    merge_sort(v, 0, n - 1, m);
}

// HEAP SORT

void heapify(int *v, size_t n, size_t i, Metrics *m) {
    size_t largest = i;
    size_t left = 2 * i + 1;
    size_t right = 2 * i + 2;

    if (left < n) {
        m->steps_cmp++;
        if (v[left] > v[largest])
            largest = left;
    }

    if (right < n) {
        m->steps_cmp++;
        if (v[right] > v[largest])
            largest = right;
    }

    if (largest != i) {
        int temp = v[i];
        v[i] = v[largest];
        v[largest] = temp;
        m->steps_swap++;

        heapify(v, n, largest, m);
    }
}

void heap_sort(int *v, size_t n, Metrics *m) {
    for (size_t i = n / 2 - 1; i < n; i--) {
        heapify(v, n, i, m);
        if (i == 0) break; 
    }

    for (size_t i = n - 1; i > 0; i--) {
        int temp = v[0];
        v[0] = v[i];
        v[i] = temp;
        m->steps_swap++;

        heapify(v, i, 0, m);
    }
}

// QUICK SORT 

void quick_sort(int *v, size_t n, Metrics *m) {
    if (n <= 1) return;

    int pivot = v[n / 2];
    size_t i = 0, j = n - 1;

    while (i <= j) {
        while (v[i] < pivot) { i++; m->steps_cmp++; }
        while (v[j] > pivot) { j--; m->steps_cmp++; }

        if (i <= j) {
            int temp = v[i];
            v[i] = v[j];
            v[j] = temp;
            m->steps_swap++;
            i++;
            j--;
        }
    }

    if (j > 0) quick_sort(v, j + 1, m);
    if (i < n) quick_sort(v + i, n - i, m);
}

// FUNÇÕES AUXILIARES 

double run_sort(void (*sort_fn)(int*, size_t, Metrics*), int *v, size_t n, Metrics *m) {
    reset_metrics(m);
    clock_t t0 = clock();
    sort_fn(v, n, m);
    clock_t t1 = clock();
    return 1000.0 * (double)(t1 - t0) / CLOCKS_PER_SEC;
}

void generate_random_array(int *v, size_t n) {
    for (size_t i = 0; i < n; i++)
        v[i] = rand() % 1000;
}

void copy_array(int *dest, int *src, size_t n) {
    for (size_t i = 0; i < n; i++)
        dest[i] = src[i];
}

// main

int main() {
    srand(time(NULL));
    
    // teste usando o RGM: 46320954
    int rgm[] = {4, 6, 3, 2, 0, 9, 5, 4};
    size_t rgm_len = sizeof(rgm) / sizeof(rgm[0]);

    Metrics m_merge, m_heap, m_quick;

    int *v_merge = malloc(rgm_len * sizeof(int));
    int *v_heap = malloc(rgm_len * sizeof(int));
    int *v_quick = malloc(rgm_len * sizeof(int));

    printf("--- Teste com RGM (46320954) ---\n");

    // Merge Sort
    copy_array(v_merge, rgm, rgm_len);
    double time_merge = run_sort(merge_sort_wrapper, v_merge, rgm_len, &m_merge);
    printf("Merge Sort: Passos = %lld, Trocas = %lld, Tempo = %.3f ms\n",
           m_merge.steps_cmp, m_merge.steps_swap, time_merge);

    // Heap Sort
    copy_array(v_heap, rgm, rgm_len);
    double time_heap = run_sort(heap_sort, v_heap, rgm_len, &m_heap);
    printf("Heap Sort : Passos = %lld, Trocas = %lld, Tempo = %.3f ms\n",
           m_heap.steps_cmp, m_heap.steps_swap, time_heap);

    // Quick Sort
    copy_array(v_quick, rgm, rgm_len);
    double time_quick = run_sort(quick_sort, v_quick, rgm_len, &m_quick);
    printf("Quick Sort: Passos = %lld, Trocas = %lld, Tempo = %.3f ms\n",
           m_quick.steps_cmp, m_quick.steps_swap, time_quick);

    free(v_merge);
    free(v_heap);
    free(v_quick);

    printf("\n--- BENCHMARK GERAL ---\n");

    for (size_t n = 100; n <= 10000; n *= 10) {
        int *random_arr = malloc(n * sizeof(int));
        int *test_arr = malloc(n * sizeof(int));

        generate_random_array(random_arr, n);

        printf("\nN = %zu:\n", n);

     copy_array(test_arr, random_arr, n);
        time_merge = run_sort(merge_sort_wrapper, test_arr, n, &m_merge);
        printf("Merge Sort: Passos = %lld, Trocas = %lld, Tempo = %.3f ms\n",
               m_merge.steps_cmp, m_merge.steps_swap, time_merge);

        copy_array(test_arr, random_arr, n);
        time_heap = run_sort(heap_sort, test_arr, n, &m_heap);
        printf("Heap Sort : Passos = %lld, Trocas = %lld, Tempo = %.3f ms\n",
               m_heap.steps_cmp, m_heap.steps_swap, time_heap);

        copy_array(test_arr, random_arr, n);
        time_quick = run_sort(quick_sort, test_arr, n, &m_quick);
        printf("Quick Sort: Passos = %lld, Trocas = %lld, Tempo = %.3f ms\n",
               m_quick.steps_cmp, m_quick.steps_swap, time_quick);

        free(random_arr);
        free(test_arr);

       
    }

    return 0;
} 
